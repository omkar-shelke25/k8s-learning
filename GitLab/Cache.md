

### **Why Caching Dependencies is Important**

In programming, most applications rely on external libraries or dependencies to function. For a Node.js application, these dependencies are listed in the `package.json` file. When you run `npm install`, it downloads these dependencies from the internet and installs them into the `node_modules` directory. This process also generates a `package-lock.json` file, which locks the exact versions of the dependencies for consistency and security.

Now, imagine you’re running a GitLab CI/CD pipeline with multiple jobs—like **unit testing** and **code coverage**—to test your application. Both jobs need the same dependencies to execute their scripts (e.g., `npm test` or `npm run coverage`). Without caching, each job runs `npm install` independently, downloading and installing the same dependencies every time. This wastes time, especially if:

- You have many dependencies (e.g., 5–9 for a simple app, or hundreds for a complex one).
- Your pipeline has multiple jobs or runs frequently.

For example, in your pipeline:
- The **unit testing job** took **7 seconds** to install 9 dependencies (adding 364 packages).
- The **code coverage job** took **6 seconds** to do the same.

If these jobs run in parallel, the total time is still 7 seconds. But if they’re sequential, that’s 13 seconds just for installing dependencies. For larger projects with hundreds of dependencies, this could take minutes per job! Multiply that by frequent pipeline runs, and you’re losing a lot of time. Caching solves this by storing the dependencies once and reusing them across jobs and pipelines, making everything faster.

---

### **How to Cache Dependencies in GitLab CI/CD**

GitLab CI/CD provides a `cache` keyword in the `.gitlab-ci.yml` file to store files (like `node_modules`) between jobs and pipelines. The cache is stored on the runner and can optionally be uploaded to a storage service like S3. Let’s explore how to set it up with an example.

#### **Key Components of the `cache` Keyword**

1. **paths**: Defines what files or directories to cache. For Node.js, we cache `node_modules/` since that’s where dependencies live.
2. **key**: A unique identifier for the cache. Jobs with the same key share the same cache. You can base the key on a file like `package-lock.json`, so the cache updates when dependencies change.
3. **policy**: Controls how the cache is used:
   - `pull-push` (default): Downloads the cache at the start and uploads changes at the end.
   - `pull`: Only downloads the cache (no upload).
   - `push`: Only uploads the cache (no download).

#### **Example Configuration**

Here’s how you can configure caching for your **unit testing** and **code coverage** jobs in `.gitlab-ci.yml`:

```yaml
unit_testing:
  stage: test
  cache:
    key:
      files:
        - package-lock.json
      prefix: "node_modules"
    paths:
      - node_modules/
    policy: pull-push
  before_script:
    - npm install
  script:
    - npm test

code_coverage:
  stage: test
  cache:
    key:
      files:
        - package-lock.json
      prefix: "node_modules"
    paths:
      - node_modules/
    policy: pull-push
  before_script:
    - npm install
  script:
    - npm run coverage
```

#### **How It Works**

1. **First Pipeline Run**:
   - No cache exists yet.
   - Both jobs run `npm install`, download the dependencies (taking 6–7 seconds each), and store `node_modules/` in the cache with a key based on `package-lock.json`.
   - The cache is uploaded (e.g., to the runner or S3).

2. **Subsequent Runs**:
   - If `package-lock.json` hasn’t changed, both jobs download the cached `node_modules/` instead of running `npm install` from scratch.
   - `npm install` verifies the dependencies are up-to-date in a fraction of a second (e.g., “up to date” message), skipping downloads.
   - Jobs then execute their scripts (`npm test` or `npm run coverage`) much faster.

3. **Cache Invalidation**:
   - If you update `package.json` and run `npm install`, the `package-lock.json` file changes.
   - The cache key (tied to `package-lock.json`) changes, so GitLab creates a new cache with the updated dependencies.

#### **Real-Time Savings**
Without caching, installing dependencies takes 6–7 seconds per job. With caching, after the first run, this drops to nearly 0 seconds per job (just verification time). For two jobs, you save over 10 seconds per pipeline run—huge for frequent runs or larger projects!

---

### **Cache vs. Artifacts**

You might wonder how caching differs from artifacts in GitLab CI/CD:
- **Cache**: Stores files (like dependencies) that don’t change often and can be reused across multiple pipelines. Example: `node_modules/`.
- **Artifacts**: Files generated by a job (e.g., test reports or build outputs) passed between jobs in the *same pipeline*. They don’t persist across pipelines unless explicitly stored.

So, use **cache** for dependencies and **artifacts** for job outputs.

---

### **Best Practices and Tips**

1. **Use a Smart Cache Key**:
   - Basing the key on `package-lock.json` ensures the cache updates when dependencies change.
   - Add a prefix (e.g., `node_modules`) for readability in logs.

2. **Handle Branches**:
   - If different branches have different dependencies, include the branch name in the key:
     ```yaml
     key: "${CI_COMMIT_REF_SLUG}-node_modules"
     ```
   - This avoids conflicts between branches.

3. **Choose the Right Policy**:
   - Use `pull-push` for jobs that might update the cache (e.g., `npm install` might tweak `node_modules`).
   - Use `pull` for read-only jobs to skip unnecessary uploads.

4. **Clearing the Cache**:
   - Manually: Go to the Pipelines section in GitLab’s UI and select “Clear Runner Cache.”
   - Automatically: Rely on the cache key (e.g., `package-lock.json`). When dependencies change, the key changes, and the cache refreshes naturally.

---

### **Putting It All Together**

Here’s what happens in your pipeline with caching:
- **First Run**: Both jobs install dependencies (13 seconds total if sequential), then cache `node_modules/`.
- **Next Run**: Both jobs pull the cache, skip downloading, and finish faster (e.g., 2–3 seconds total for verification and testing).
- **Dependency Change**: Update `package.json`, `package-lock.json` changes, the cache key updates, and new dependencies are cached.

This optimization saves time, reduces resource usage, and keeps your pipeline efficient—especially as your Node.js app grows!


